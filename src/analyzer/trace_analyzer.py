from typing import List, Tuple

from src.analyzer.harmful_trace import HarmfulTrace, RaceType
from src.analyzer.transition_checker import TransitionsChecker
from src.model.dnk_maude_model import ElementMetadata
from src.trace.node import TraceNode


class TraceAnalyzerError(Exception):
    pass


def _validateTrace(trace: List[TraceNode], elsMetadata: List[ElementMetadata]) -> None:
    """Raises TraceAnalyzerError if the vector clocks of any nodes in
    the given trace does not match the number of elements of
    the metadata list."""
    elsNr = len(elsMetadata)
    for i, node in enumerate(trace):
        if i > 0 and node.trans.getSource() is None:
            raise TraceAnalyzerError(
                f"Transition of trace node {i} has no source element, "
                + "so it is likely an empty transition. "
                + "Only the first node of the trace can have an empty transition."
            )

        if i > 0 and not node.trans.hasValidPositions(elsMetadata):
            raise TraceAnalyzerError(
                f"Unknown type for elements that are part of transition of node {i}. "
                + "This may suggest that the wrong DNK model information "
                + f"was passed to {TraceAnalyzer.__name__}."
            )
        if len(node.vectorClocks) != elsNr:
            raise TraceAnalyzerError(
                f"Number of vector clocks of trace node {i} does "
                + f"not match the number of expected elements ({elsNr})"
            )
        for vc in node.vectorClocks:
            if len(vc) != elsNr:
                raise TraceAnalyzerError(
                    f"Vector clock size of trace node {i} does not match "
                    + f"the number of expected elements ({elsNr})"
                )


class TraceAnalyzer:
    def __init__(
        self, transChecker: TransitionsChecker, elsMetadata: List[ElementMetadata]
    ) -> None:
        self._transChecker = transChecker
        self._elsMetadata = elsMetadata
        self._trace: List[TraceNode] = []
        # maps element position to last node with a transition generated by element
        self._elLastNode: dict[int, int] = {}
        self.__skippedRaces: dict[RaceType, int] = {}

    def analyze(self, trace: List[TraceNode]) -> HarmfulTrace | None:
        """Does not account for policies/flow rules that are appended to a flow table.
        Raises TraceAnalyzerError if something goes wrong during the analysis."""
        self._trace = trace
        self._elLastNode = {}
        _validateTrace(self._trace, self._elsMetadata)
        for i, node in enumerate(self._trace):
            if i == 0 and not node.trans.policy:
                continue  # skip empty start node
            el1 = node.trans.getSource()
            if el1 is None:
                raise TraceAnalyzerError("Found transition without source")
            # for rcfgs, we don't update the last node of the switch (i.e. the
            # destination of the rcfg) because we are interested in races
            # where the switch processes a packet.
            self._elLastNode[el1] = i
            for el2 in self._findElementsRacingWith(el1):
                res = self._checkRace(el1, el2)
                if res is None:
                    continue
                return HarmfulTrace(self._trace, self._elsMetadata, res[0], res[1])
        return None

    def _findElementsRacingWith(self, el1: int) -> List[int]:
        racingElements: List[int] = []
        vc1 = self._trace[self._elLastNode[el1]].vectorClocks[el1]
        for el2, node2Pos in self._elLastNode.items():
            if el2 == el1:
                continue
            vc2 = self._trace[node2Pos].vectorClocks[el2]
            if (vc1[el1] <= vc2[el1] and vc1[el2] <= vc2[el2]) or (
                vc1[el1] >= vc2[el1] and vc1[el2] >= vc2[el2]
            ):
                continue
            racingElements.append(el2)
        return racingElements

    def _checkRace(self, el1: int, el2: int) -> Tuple[dict[int, int], RaceType] | None:
        node1Pos = self._elLastNode[el1]
        node2Pos = self._elLastNode[el2]
        raceType = self._transChecker.check(self._trace, node1Pos, node2Pos)
        if raceType is not None:
            return {node1Pos: el1, node2Pos: el2}, raceType
        return None
