---- Copyright (c) 2021 University of Konstanz
---- 
---- Permission is hereby granted, free of charge, to any person obtaining a copy
---- of this software and associated documentation files (the "Software"), to deal
---- in the Software without restriction, including without limitation the rights
---- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
---- copies of the Software, and to permit persons to whom the Software is
---- furnished to do so, subject to the following conditions:
---- 
---- The above copyright notice and this permission notice shall be included in all
---- copies or substantial portions of the Software.
---- 
---- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
---- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
---- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
---- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
---- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
---- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
---- SOFTWARE.

fmod MAP_UTIL{X :: TRIV, Y :: TRIV} is
  protecting NAT .
  protecting MAP {X, Y} .

  op mapLength_ : Map {X, Y} -> Nat .

  var I : X$Elt .
  var E : Y$Elt .
  var M : Map {X, Y} .

  eq mapLength empty = 0 .
  eq mapLength ((I |-> E) , M) = s(mapLength M) .
endfm

fmod VECTOR_CLOCK is 
	protecting MAP {Nat, Nat} * (sort Map {Nat, Nat} to VClock) .
  
  op newVC(_) : Nat -> VClock .
  op inc(_,_) : VClock Nat -> VClock .

  op maxVC(_,_) : VClock VClock -> VClock .

  vars VC1 VC2 : VClock .
  vars N I J X : Nat .

  eq newVC(0) = empty .
  eq newVC(s(N)) = insert(N, 0, newVC(N)) .

  ceq inc(VC1, I) = insert(I, s(VC1[I]), VC1) if not VC1[I] == undefined .

  
  ---- Returns a new vector clock with the maximum values of all common entries of the two given vector clocks
  ---- Example: maxVC((0 |-> 1, 1 |-> 3, 2 |-> 4),
  ----                (0 |-> 2, 2 |-> 2, 4 |-> 5)) reduces to (0 |-> 2, 2 |-> 4)

  eq maxVC(VC1, empty) = empty .
  eq maxVC(empty, VC2) = empty .
  eq maxVC((I |-> X, VC1), VC2)
    = if VC2[I] =/= undefined
      then insert(I, max(X, VC2[I]), maxVC(VC1, VC2))
      else maxVC(VC1, VC2)
      fi .
endfm

view VCLOCK from TRIV to VECTOR_CLOCK is
  sort Elt to VClock .
endv

fmod VECTOR_CLOCK_MAP is
  protecting VECTOR_CLOCK .
  protecting MAP_UTIL {Nat, VCLOCK} * (sort Map {Nat, VCLOCK} to VCMap) .

  --- Assumes the position corresponds to the correct vector clock of a component in the map, but also to the same component in the vector clock itself
  op inc(_,_) : VCMap Nat -> VCMap .
  --- Applies the transfer rule between 2 vector clocks: vc1 becomes vc1[i]++ and vc2 becomes max(vc1[i]++, vc2)[j]++ 
  op transferVC(_,_,_) : VCMap Nat Nat -> VCMap .
  op newVCMap(_) : Nat -> VCMap .
  op newVCMapAux(_,_) : Nat Nat -> VCMap .

  var VCs : VCMap .
  vars I J VCSize : Nat .

  ceq inc(VCs, I) = insert(I, inc(VCs[I], I), VCs) if VCs[I] =/= undefined .

  ceq transferVC(VCs, I, J) = insert(J, inc(maxVC(inc(VCs[I], I), VCs[J]), J), inc(VCs, I)) if (VCs[I] =/= undefined) /\ (VCs[J] =/= undefined) .

  --- creates a map containing the same amount of vector clocks as a vector clock size (equivalent to the nr of components)
  eq newVCMap(VCSize) = newVCMapAux(VCSize, VCSize) .
  eq newVCMapAux(0, VCSize) = empty .
  eq newVCMapAux(s(I), VCSize) = insert(I, newVC(VCSize), newVCMapAux(I, VCSize)) .
endfm

fmod COMM is
	protecting STRING .
	sorts Comm Channel .

	op _?_ : Channel String -> Comm .
	op _!_ : Channel String -> Comm .
endfm

view Comm from TRIV to COMM is
	sort Elt to Comm .
endv

fmod DNA is
	protecting COMM .
	protecting TRUTH-VALUE .
	protecting SET {Comm} * (sort Set {Comm} to TermSet) .

	sorts DNA Recursive RecursiveVC UnguardedTerm DNA_VC .
  subsort Recursive < DNA .
	subsort RecursiveVC < UnguardedTerm < DNA_VC .

	op _o+_ : DNA DNA -> DNA [ctor comm assoc metadata "nondeterministic choice" prec 43] .
	op _;_ : String DNA -> DNA [ctor metadata "sequential composition" prec 40 gather (E e)] .
	op _;_ : Comm DNA -> DNA [ctor metadata "sequential composition" prec 40 gather (E e)] .

	op bot : -> DNA .
	op rcfg(_,_) : Channel String -> Comm .
	op delta{_}(_) : TermSet DNA -> DNA . 
	op pi{_}(_) : Nat DNA -> DNA .

	var H : TermSet . 
	var M : Nat .
	var X : Channel .
	vars P Q R : DNA .
	vars N Z : String .

	op zero : -> String .

	eq zero ; P = bot .

	eq [A0] : (N + Z) ; R = N ; R o+ Z ; R .
	---A1: added comm to _o+_
	---A2: added assoc to _o+_
	eq [A3] : (P o+ P) = P .
	eq [A4] : (P o+ bot) = P .
endfm

view DNA from TRIV to DNA is
  sort Elt to DNA .
endv

view DNA_VC from TRIV to DNA is
  sort Elt to DNA_VC .
endv
