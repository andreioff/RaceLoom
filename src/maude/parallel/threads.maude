load metaInterpreter.maude
load queue.maude

fmod FIBO is
protecting NAT .
op fibo : Nat -> Nat .
var N : Nat .
eq fibo(0) = 0 .
eq fibo(1) = 1 .
eq fibo(s s N) = fibo(N) + fibo(s N) .
endfm

mod THREADS is
extending META-INTERPRETER .

protecting FIBO .
protecting CONVERSION .
protecting IQUEUE{Worker} .

sort PState .

op manager : -> Oid .
op User : -> Cid .

op inputList:_ : TermList -> Attribute .
op resultList:(_,_) : TermList Nat -> Attribute .
op #workers:_ : Nat -> Attribute .
op workers:_ : Queue{Worker} -> Attribute .

op state:_ : PState -> Attribute .
ops PInit PWorking PFinished : -> PState .

op extractRes(_) : Configuration -> String .
op extractError : -> [Nat] .

op p-run : Nat TermList -> Configuration .
op init : Oid Nat -> Msg [ctor msg] .

vars X Y WID : Oid .
var AS : AttributeSet .
vars K N R R2 : Nat .
vars T T2 T3 : Term .
var IL TL : TermList .
var ResType : Type .
var W : Queue{Worker} .

eq p-run(0, IL) = < manager : User | state: PFinished, resultList: (empty, 0) > .
eq p-run(N, empty) = < manager : User | state: PFinished, resultList: (empty, 0) > .
eq p-run(N, IL)
  = < manager : User | inputList: IL >
  ---- TODO inputList length should match no. of workers, so you get a list of lists of trace nodes (1 per worker)
  init(manager, N) .

op produceInterpreter : Oid Nat -> Configuration .
eq produceInterpreter(X, 0) = none .
eq produceInterpreter(X, s(N)) = createInterpreter(interpreterManager, X, newProcess)
    produceInterpreter(X, N) .

eq extractRes(<> < X : User | state: PFinished, resultList: (empty, R), AS >) = " rewrites: " + string(R, 10) .
eq extractRes(<> < X : User | state: PFinished, resultList: ((T, TL), R), AS >) = string(downTerm(T, extractError), 10) +
  " " + extractRes(<> < X : User | state: PFinished, resultList: (TL, R), AS >).

rl < X : User |
    inputList: TL,
    AS >
    init(X, N)
=> < X : User |
    state: PInit,
    #workers: N,
    workers: emptyq,
    inputList: TL,
    resultList: (empty, 0),
    AS >
    produceInterpreter(X, N) .

rl < X : User | 
  state: PInit,
    AS >
createdInterpreter(X, Y, WID)
=> < X : User | 
  state: PInit,
    AS >
    insertModule(WID, X, upModule('THREADS, true)) .

rl < X : User | 
  state: PInit,
  workers: W,
  AS >
insertedModule(X, WID)
=> < X : User | 
  state: PInit,
  workers: (W | WID),
  AS > .

crl < X : User | 
    state: PInit,
    #workers: N,
    workers: W,
    AS >
=> < X : User | 
  state: PWorking,
  #workers: N,
  workers: W,
  AS >
if N == qsize(W) .

rl < X : User | 
  state: PWorking,
  inputList: (T, TL),
  workers: (WID | W),
  AS >
=> < X : User | 
  state: PWorking,
  inputList: TL,
  workers: W,
  AS >
  reduceTerm(WID, X, 'THREADS, 'fibo[T]) .

rl < X : User |
  state: PWorking,
  workers: W,
  resultList: (TL, R),
  AS >
  reducedTerm(X, WID, R2, T, ResType)
=> < X : User | 
    state: PWorking,
    workers: (W | WID),
    resultList: ((TL, T), (R2 + R)),
    AS  
   > .

crl < X : User |
    state: PWorking,
    #workers: N,
    workers: W,
    inputList: empty,
    AS >
=> < X : User |
    state: PFinished,
    #workers: N,
    workers: W,
    inputList: empty,
    AS > 
if N == qsize(W) .

endm

---- test cmd
---- erewrite extractRes(<> p-run(10, (upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33), upTerm(33)))) .
