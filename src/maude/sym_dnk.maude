load dnk_vc.maude
load vector_clock.maude

fmod DNA_VC_MAP is
  protecting VECTOR_CLOCK_MAP .
  protecting DNA .

  sort DNA_VC_MAP .

  --- DNA term + map of vector clocks
  op dnaVCMap(_,_) : DNA VCMap -> DNA_VC_MAP .

  --- DNA term + key of corresponding vector clock in a map
  op vc : DNA Nat -> DNA_VC .
endfm


view DNA_VC_MAP from TRIV to DNA_VC_MAP is
  sort Elt to DNA_VC_MAP .
endv


fmod SYMBOLIC_RULE_RESULT is
  protecting DNA_VC_MAP .

  sort SymRuleResult .

  --- A symbolic rule result contains a symbolic configuration after applying 1 symbolic semantic rule on it, 
  --- a corresponding transition step (if any), and the updated map of vector clocks (if modified)
  op transRes(_,_,_) : DNA_VC DNA VCMap -> SymRuleResult .
  op rewriteRes(_) : DNA_VC -> SymRuleResult .
endfm


view SYMBOLIC_RULE_RESULT from TRIV to SYMBOLIC_RULE_RESULT is
  sort Elt to SymRuleResult .
endv


fmod SYM_DNA is 
  protecting SYMBOLIC_RULE_RESULT .
  protecting LIST {SYMBOLIC_RULE_RESULT} * (sort List {SYMBOLIC_RULE_RESULT} to SymRuleResults) .

  op applySymRule(_,_) : DNA_VC VCMap -> SymRuleResults .

	op _||_ : DNA_VC DNA_VC -> DNA_VC [ctor comm metadata "parallel composition" prec 42 gather (E e)] .
	op _|_ : DNA_VC DNA_VC -> DNA_VC [ctor comm prec 42 gather (E e)] .
	op _||<_ : DNA_VC DNA_VC -> DNA_VC [ctor metadata "left merge" prec 42 gather (e E)] .

  var VCs : VCMap .
  var X : Channel .
  vars P Q : DNA_VC .
  vars U V : DNA .
  vars D I J : Nat .
  var N : String .

	---A5: added comm to _||_
	---A6: added assoc to _||_

	--- eq [A7] : (P || bot) = P .
  eq [A7] : applySymRule((P || vc(bot, I)), VCs) = (rewriteRes(P) nil) .

	--- ceq [A8] : (P || Q) = (P ||< Q) o+ (Q ||< P) o+ (P | Q) if not (P :: Recursive) /\ not (P :: UnguardedTerm) /\ not (Q :: Recursive) /\ not (Q :: UnguardedTerm) .
  ceq [A8] : applySymRule((P || Q), VCs) = (rewriteRes(P ||< Q) rewriteRes(Q ||< P) rewriteRes(P | Q) nil)
                                    if not (P :: RecursiveVC) /\ not (P :: UnguardedTerm) /\ not (Q :: RecursiveVC) /\ not (Q :: UnguardedTerm) .

	--- eq [A9] : (bot ||< P) = bot .
  eq [A9] : applySymRule((vc(bot, I) ||< P), VCs) = (rewriteRes(vc(bot, I)) nil) .

	--- eq [A10-netkat] : (N ; P) ||< Q = N ; (P || Q) .
  eq [A10-netkat] : applySymRule((vc(N ; U, I) ||< Q), VCs) = (transRes((vc(U, I) || Q), (N ; bot), inc(VCs, I)) nil) .

	--- eq [A10-send] : ((X ! N) ; Q) ||< R = ((X ! N) ; (Q || R)) .
  eq [A10-send] : applySymRule((vc((X ! N) ; U, I) ||< Q), VCs) = (transRes((vc(U, I) || Q), ((X ! N) ; bot), inc(VCs, I)) nil) .

	--- eq [A10-receive] : ((X ? N) ; Q) ||< R = ((X ? N) ; (Q || R)) .
  eq [A10-receive] : applySymRule((vc((X ? N) ; U, I) ||< Q), VCs) = (transRes((vc(U, I) || Q), ((X ? N) ; bot), inc(VCs, I)) nil) .

	--- eq [A10-rcfg] : ((rcfg(X, N)) ; Q) ||< R = ((rcfg(X, N)) ; (Q || R)) .
  --- A12 produces the rcfg as transition, so A10-rcfg is not needed anymore

	--- eq [A11] : (P o+ Q) ||< R = (P ||< R) o+ (Q ||< R) .
  eq [A11] : applySymRule((vc(U o+ V, I) ||< Q), VCs) = (rewriteRes(vc(U, I) ||< Q) rewriteRes(vc(V, I) ||< Q) nil) .

	--- eq [A12] : ((X ? N) ; Q) | ((X ! N) ; R) = (rcfg(X, N)) ; (Q || R) .
  eq [A12] : applySymRule((vc((X ? N) ; U, I) | vc((X ! N) ; V, J)), VCs) = (transRes((vc(U, I) || vc(V, J)), (rcfg(X, N) ; bot), transferVC(VCs, J, I)) nil) .

	--- eq [A13] : (P o+ Q) | R = (P | R) o+ (Q | R) .
  eq [A13] : applySymRule((vc(U o+ V, I) | Q), VCs) = (rewriteRes(vc(U, I) | Q) rewriteRes(vc(V, I) | Q) nil) .

	---A14: added comm to _|_

	--- ceq [A15] : P | Q = bot if not (P :: Recursive) /\ not (P :: UnguardedTerm) /\ not (Q :: Recursive) /\ not (Q :: UnguardedTerm) [owise] .
	ceq [A15] : applySymRule((P | Q), VCs) = nil if not (P :: RecursiveVC) /\ not (P :: UnguardedTerm) /\ not (Q :: RecursiveVC) /\ not (Q :: UnguardedTerm) .

	--- eq [cr-1] : P ||< bot = P .
  eq [cr-1] : applySymRule((P ||< vc(bot, I)), VCs) = (rewriteRes(P) nil) .
endfm


fmod RECURSIVE_SYM_DNA is
	protecting SYM_DNA .

	var C : Comm .
	var N : String .
  var I : Nat .
	vars P Q : DNA_VC .
  var U : DNA .
  var VCs : VCMap .

	op getRecPol(_) : Recursive -> DNA .
	op unfold(_) : DNA_VC -> DNA_VC .
	op notUnfolded(_) : DNA_VC -> Bool .


	---unfolding the recursive variables at once is very inefficient.
	---we perform the unfolding on the fly when it is necessary
	---i.e. when the execution cannot continue because the terms are not guarded.
	
	ceq unfold(P || Q) = (unfold(P) || Q) if (P :: UnguardedTerm) .
	ceq unfold(P ||< Q) = (unfold(P) ||< Q) if (P :: UnguardedTerm) .
	ceq unfold(P | Q) = (unfold(P) | Q) if (P :: UnguardedTerm) .
	ceq unfold(vc(U, I)) = vc(getRecPol(U), I) if (U :: Recursive) .

	eq notUnfolded(unfold(P)) = false .
	eq notUnfolded(P) = true [owise] .

	ceq [rec-1] : applySymRule(P, VCs) = applySymRule(unfold(P), VCs) if notUnfolded(P) [owise] .
	cmb [rec-2] : (P || Q) : UnguardedTerm if ((P :: RecursiveVC) or (P :: UnguardedTerm)) .
	cmb [rec-3] : (P ||< Q) : UnguardedTerm if ((P :: RecursiveVC) or (P :: UnguardedTerm)) .
  cmb [rec-4] : vc(U, I) : RecursiveVC if (U :: Recursive) .
endfm
