load dnk.maude
load vector_clock.maude

load dnk_model_util.maude
load trace_state.maude
load metaInterpreter.maude
load parallel_trace_state.maude
load trace_tree.maude

fmod TRACE-STATES-TO-TRACE-TREE is
  protecting RECURSIVE-DNK .
  protecting TRACE-STATE .
  protecting TRACE-TREE .
	protecting MAP-UTIL {Nat, TraceNodes} * (sort Map {Nat, TraceNodes} to TraceNodesMap) .
  protecting EXT-BOOL . 

  var N : String .
  var NTy : NType .
  var VCs : VCMap .
  var P : DNKComp .
  vars L ID PID : Nat .
  var T : TNType .
  var TN : TraceNode .
  var TNs : TraceNodes .
  vars Nodes RemNodes : NodeList .
  vars M ChildrenM : TraceNodesMap .
  var NLM : NodeListMap .

  op $insertTN(_,_,_) : Nat TraceNode TraceNodesMap -> TraceNodesMap .
  eq $insertTN(ID, TN, empty) = (ID |-> TAppend(TN, TEmpty)) .
  eq $insertTN(ID, TN, (M, ID |-> TNs)) = (M, ID |-> TAppend(TN, TNs)) .
  eq $insertTN(ID, TN, M) = (M, ID |-> TAppend(TN, TEmpty)) .

  op $getChildren(_,_) : Nat TraceNodesMap -> TraceNodes .
  eq $getChildren(ID, empty) = TEmpty .
  eq $getChildren(ID, (ChildrenM, ID |-> TNs)) = TNs .
  eq $getChildren(ID, (ChildrenM, L |-> TNs)) = TEmpty .

  op TNMapPrepend(_,_) : NodeList TraceNodesMap -> TraceNodesMap .
  ---- These 2 equations have to explicitly match the second argument
  ---- as a map constructor because unreduced terms that return a map could also
  ---- be matched, preventing Maude from reducing them before applying these equations.
  eq TNMapPrepend(Nodes, empty) = $TNMapPrepend(Nodes, empty, empty) .
  eq TNMapPrepend(Nodes, (ID |-> TNs, ChildrenM)) = $TNMapPrepend(Nodes, (ID |-> TNs, ChildrenM), empty) .

  op $TNMapPrepend(_,_,_) : NodeList TraceNodesMap TraceNodesMap -> TraceNodesMap .
  eq $TNMapPrepend(nil, ChildrenM, M) = M .
  eq $TNMapPrepend((snode(ID, P, VCs) RemNodes), ChildrenM, M) = $TNMapPrepend(
    RemNodes,
    ChildrenM,
    $insertTN(ID, TNode(TSTART, "", VCs, $getChildren(ID, ChildrenM)), M)
  ) .
  eq $TNMapPrepend((node(ID, PID, P, nd(NTy, N), VCs) RemNodes), ChildrenM, M) = $TNMapPrepend(
    RemNodes,
    ChildrenM,
    $insertTN(PID, TNode(TNORMAL, N, VCs, $getChildren(ID, ChildrenM)), M)
  ) .

  op flattenTNMap(_) : TraceNodesMap -> TraceNodes .
  eq flattenTNMap(empty) = TEmpty .
  eq flattenTNMap((M, ID |-> TNs)) = TConcat(TNs, flattenTNMap(M)) .
endfm

mod TRACER-UTIL is 
  protecting STRING .
	protecting RECURSIVE-DNK .
  protecting MAP-UTIL {Nat, RDNK} * (sort Map {Nat, RDNK} to RDNKMap) .

  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op parallelJoin(_,_,_) : RDNK RDNKMap Nat -> DNKComp .

  var Cs : RDNKMap . 
  vars BSw C : RDNK .
  vars I VCSize : Nat .

  eq parallelJoin(BSw, empty, VCSize) = c(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || c(C, s(I))) .
endm

mod TRACER is
  protecting TRACE-COLLECTOR .
  protecting PARALLEL-COMPUTE-NEXT-LAYER .
  protecting COMM-STRING-CONVERSION .
  protecting TRACER-UTIL .
  protecting CONVERSION .
  protecting TRACE-STATES-TO-TRACE-TREE .

	op rd{_}{_}(_,_) : Configuration Nat NodeList Nat -> TraceNodesMap .
	op $rd{_}{_}(_) : Configuration Nat AssignIdsResult -> TraceNodesMap .

	op tracer{_}{_}(_,_) : Configuration Nat RDNK RDNKMap -> String .

  var Cs : RDNKMap . 
  vars P Q : DNKComp .
  vars N TR : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : RDNK .
  vars I J D K ID PID NID : Nat .
  vars Nodes RemNodes : NodeList .
  var TN : Node .
  var WorkersConfig : Configuration .
  var M : Oid .
  var AS : AttributeSet .
 

  eq rd{WorkersConfig}{0}(Nodes, NID) = TNMapPrepend(Nodes, empty) .
  eq rd{WorkersConfig}{D}(nil, NID) = empty .
  eq rd{WorkersConfig}{s(D)}(Nodes, NID) = TNMapPrepend(Nodes, 
    $rd{WorkersConfig}{D}(
      assignIds(
        cnlParallel(WorkersConfig, Nodes),
        NID
      )
    )) .
  eq $rd{WorkersConfig}{D}(assignIdsResult(Nodes, NID)) = rd{WorkersConfig}{D}(Nodes, NID) .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_RDNK, 1 |-> second_RDNK, 2 |-> third_RDNK, etc.
  eq tracer{WorkersConfig}{0}(BSw, Cs) = "" .
  eq tracer{<> < M : User | state: PReady, AS >}{D}(BSw, Cs) = collectTraces(flattenTNMap(
    rd{< M : User | state: PReady, AS >}{D}(
        snode(0, parallelJoin(BSw, Cs, s(mapLength(Cs))), newVCMap(s(mapLength(Cs)))),
        1
      )
  )).
endm
