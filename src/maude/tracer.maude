load dnk.maude
load trace_tree.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting RECURSIVE_DNK .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to StrMap) .
  protecting MAP_UTIL {Nat, RDNK} * (sort Map {Nat, RDNK} to RDNKMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : StrMap -> String .
  op network__ : StrMap String -> String [gather (E e)].
  op bigSwitch__ : StrMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : RDNK RDNKMap Nat -> DNKComp .

  var Sws : StrMap .
  var Cs : RDNKMap . 
  vars BSw C : RDNK .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + L .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = c(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || c(C, s(I))) .
endfm

fmod TRACER is
  protecting TRACE_TREE .
  protecting COMM_STRING_CONVERSION .
  protecting TRACER_UTIL .

	op rd{_,_}(_,_) : Nat Bool DNKComp VCMap -> TraceNodes .
	op makeNode{_,_}(_,_,_) : Nat Bool String DNKComp VCMap -> TraceNodes .

	op tracer{_,_}(_,_) : Nat Bool RDNK RDNKMap -> TraceNodes .
	op tracerAux{_,_}(_,_) : Nat Bool DNKComp VCMap -> TraceNodes .

  var Cs : RDNKMap . 
  var P Q : DNKComp .
  var N : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : RDNK .
  vars I J D : Nat .
  var All : Bool .

  ceq makeNode{D, All}(N, P, VCs) = TAppend(TNode(TDR, N, VCs, TEmpty), TEmpty) if hasIncmpVCs(VCs) .
  eq makeNode{D, true}(N, P, VCs) = TAppend(TNode(TNORMAL, N, VCs, rd{D, true}(P, VCs)), TEmpty) .
  ceq makeNode{D, false}(N, P, VCs) = TAppend(TNode(TNORMAL, N, VCs, rd{D, false}(P, VCs)), TEmpty) if (rd{D, false}(P, VCs) =/= TEmpty) .
  eq makeNode{D, false}(N, P, VCs) = TEmpty [owise] .

  eq rd{0, All}(P, VCs) = TEmpty .
  eq rd{D, All}(c(bot, I), VCs) = TEmpty .

  eq rd{D, true}(P o+ Q, VCs) = TConcat(rd{D, true}(P, VCs), rd{D, true}(Q, VCs)) . ---- TODO: Concat only if it doesn't lead to TEmpty
  ceq rd{D, false}(P o+ Q, VCs) = rd{D, false}(P, VCs) if (rd{D, false}(P, VCs) =/= TEmpty) .
  eq rd{D, false}(P o+ Q, VCs) = rd{D, false}(Q, VCs) [owise] .

  ---- Sending or receiving alone does not count in the trace, which is similar to applying the delta operator.
  ---- The trace also stops here since the expected behavior of a component is to wait when executing a
  ---- communication instruction until it can synchronize with another component.
  eq rd{s(D), All}(c((X ! N), I) ; P, VCs) = TEmpty .
  eq rd{s(D), All}(c((X ? N), I) ; P, VCs) = TEmpty .
  eq rd{s(D), All}(rcfg(X, N, I, J) ; P, VCs) = makeNode{D, All}(compCommToStr(rcfg(X, N, I, J)), P, transferVC(VCs, I, J)) .

  eq rd{s(D), All}(c(N, I) ; P, VCs) = makeNode{D, All}(N, P, inc(VCs, I)) .

	ceq [rec-4] : rd{D, All}(P, VCs) = rd{D, All}(unfold(P), VCs) if notUnfolded(P) [owise] .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_RDNK, 1 |-> second_RDNK, 2 |-> third_RDNK, etc.
  eq tracer{D, All}(BSw, Cs) = tracerAux{D, All}(parallelJoin(BSw, Cs, s(mapLength(Cs))),
                                       newVCMap(s(mapLength(Cs)))) .
  ceq tracerAux{D, All}(P, VCs) = TAppend(TNode(TSTART, "", VCs, rd{D, All}(P, VCs)), TEmpty) if rd{D, All}(P, VCs) =/= TEmpty . ---- Add start node if trace is not empty
  eq tracerAux{D, All}(P, VCs) = TEmpty [owise] .
endfm
