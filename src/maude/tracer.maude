load sym_dnk.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to SwMap) .

  op concatSws_ : SwMap -> String .
  op network__ : SwMap String -> String [gather (E e)].
  op bigSwitch__ : SwMap String -> String [gather (E e)].

  var Sws : SwMap .
  var I : Nat .
  vars L, X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + L .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .
endfm

fmod TRACER is
	protecting RECURSIVE_SYM_DNA .
  protecting MAP_UTIL {Nat, DNA} * (sort Map {Nat, DNA} to DNAMap) .
  protecting TRACER_UTIL .

  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .
  
  op parallelJoin(_,_,_) : DNA DNAMap Nat -> DNA_VC .
	op tracer{_}(_,_) : Nat DNA DNAMap -> DNAVCList [gather (e e E)] .

  vars Cs : DNAMap . 
  vars BSw C : DNA .
  var N VCSize : Nat .

  eq parallelJoin(BSw, empty, VCSize) = vc(BSw, 0) .
  eq parallelJoin(BSw, (N |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || vc(C, s(N))) .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_DNA, 1 |-> second_DNA, 2 |-> third_DNA, etc.
  eq tracer{N}(BSw, Cs) = rd{N}(parallelJoin(BSw, Cs, s(mapLength(Cs))),
                                newVCMap(s(mapLength(Cs))),
                                nil) .
endfm

fmod TESTING is
  protecting TRACER .

  op SDN_ : SwMap -> Recursive .
  ops SW SWP C C0 : -> Recursive .
	ops Help Up Up0 : -> Channel .

  var Sws : SwMap .

  eq getRecPol(SW) = "(f = r) . (pt = 1) . (pt <- 2)" ; SW o+
                      "(f = b) . (pt = 1)" ; ( (Help ! "one") ; SW ) o+
                      (Up ? "one") ; SWP .
  eq getRecPol(SWP) = "zero" ; SWP . ---- the "zero" atom should be without quotes, but the axioms reduce it to bot which prevents rd from finishing
  eq getRecPol(C) = (Help ? "one") ; ( (Up ! "one") ; C ) .
endfm
