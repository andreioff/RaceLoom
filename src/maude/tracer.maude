load sym_dnk.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting RECURSIVE_SYM_DNA .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to StrMap) .
  protecting MAP_UTIL {Nat, DNA} * (sort Map {Nat, DNA} to DNAMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : StrMap -> String .
  op network__ : StrMap String -> String [gather (E e)].
  op bigSwitch__ : StrMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : DNA DNAMap Nat -> DNA_VC .

  var Sws : StrMap .
  var Cs : DNAMap . 
  vars BSw C : DNA .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + L .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = vc(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || vc(C, s(I))) .
endfm


fmod TRACER is
  protecting TRACE_TREE .
  protecting TRACER_UTIL .

	op rd{_,_}(_,_) : Nat Bool DNA_VC VCMap -> TraceNodes .
	op procResult{_,_}(_,_) : Nat Bool SymRuleResults VCMap -> TraceNodes .

	op tracer{_,_}(_,_) : Nat Bool DNA DNAMap -> TraceNodes .
	op tracerAux{_,_}(_,_) : Nat Bool DNA_VC VCMap -> TraceNodes .

  var Results : SymRuleResults .
  var Cs : DNAMap . 
  var P : DNA_VC .
  var N : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : DNA .
  vars I D : Nat .
  var commTransRes : CommTransResult .
  var All : Bool .


  eq procResult{0, All}(Results, VCs) = TEmpty .
  eq procResult{D, All}(nil, VCs) = TEmpty .

  eq procResult{D, true}((rewriteRes(P) Results), VCs) = TConcat(rd{D, true}(P, VCs), procResult{D, true}(Results, VCs)) .
  ceq procResult{D, false}((rewriteRes(P) Results), VCs) = rd{D, false}(P, VCs) if (rd{D, false}(P, VCs) =/= TEmpty) .
  eq procResult{D, false}((rewriteRes(P) Results), VCs) = procResult{D, false}(Results, VCs) [owise] .

  ---- Sending or receiving alone does not count in the trace, which is similar to applying the delta operator.
  ---- The trace also stops here since the expected behavior of a component is to wait when executing a
  ---- communication instruction until it can synchronize with another component.
  eq procResult{s(D), All}((transRes(P, (X ! N), NewVCs) nil), VCs) = TEmpty .
  eq procResult{s(D), All}((transRes(P, (X ? N), NewVCs) nil), VCs) = TEmpty .
  eq procResult{D, All}(commTransRes, VCs) = procResult{D, All}((ToStrTrans(commTransRes) nil), VCs) . --- Any other communication is converted to string

  ceq procResult{s(D), All}((transRes(P, N, NewVCs) nil), VCs) = TAppend(TNode(TDR, N, NewVCs, TEmpty), TEmpty) if hasIncmpVCs(NewVCs) .
  eq procResult{s(D), true}((transRes(P, N, NewVCs) nil), VCs) = TAppend(TNode(TNORMAL, N, NewVCs, rd{D, true}(P, NewVCs)), TEmpty) .
  ceq procResult{s(D), false}((transRes(P, N, NewVCs) nil), VCs) = TAppend(TNode(TNORMAL, N, NewVCs, rd{D, false}(P, NewVCs)), TEmpty) if (rd{D, false}(P, NewVCs) =/= TEmpty) .
  eq procResult{s(D), false}((transRes(P, N, NewVCs) nil), VCs) = TEmpty [owise] .


  eq rd{0, All}(P, VCs) = TEmpty .
  eq rd{D, All}(vc(bot, I), VCs) = TEmpty .
  eq rd{D, All}(P, VCs) = procResult{D, All}(applySymRule(P, VCs), VCs) .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_DNA, 1 |-> second_DNA, 2 |-> third_DNA, etc.
  eq tracer{D, All}(BSw, Cs) = tracerAux{D, All}(parallelJoin(BSw, Cs, s(mapLength(Cs))),
                                       newVCMap(s(mapLength(Cs)))) .
  ceq tracerAux{D, All}(P, VCs) = TAppend(TNode(TSTART, "", VCs, rd{D, All}(P, VCs)), TEmpty) if rd{D, All}(P, VCs) =/= TEmpty . ---- Add start node if trace is not empty
  eq tracerAux{D, All}(P, VCs) = TEmpty [owise] .
endfm
