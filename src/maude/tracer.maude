load dnk.maude
load trace_tree.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting RECURSIVE_DNK .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to StrMap) .
  protecting MAP_UTIL {Nat, RDNK} * (sort Map {Nat, RDNK} to RDNKMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .
  op CollectTrace : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : StrMap -> String .
  op network__ : StrMap String -> String [gather (E e)].
  op bigSwitch__ : StrMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : RDNK RDNKMap Nat -> DNKComp .

  var Sws : StrMap .
  var Cs : RDNKMap . 
  vars BSw C : RDNK .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + "(" + L + ")" .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = c(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || c(C, s(I))) .
endfm


fmod TRACER is
  protecting TRACE_TREE .
  protecting COMM_STRING_CONVERSION .
  protecting TRACER_UTIL .
  protecting CONVERSION .

  sorts STEPTYPE .
  op CommStep : -> STEPTYPE [ctor] .
  op ProcStep : -> STEPTYPE [ctor] .
  op NoStep : -> STEPTYPE [ctor] .
 
	op rd{_,_}(_,_,_) : Nat STEPTYPE DNKComp VCMap String -> String .
	op checkClocks{_,_}(_,_,_) : Nat STEPTYPE DNKComp VCMap String -> String .

	op tracer{_}(_,_) : Nat RDNK RDNKMap -> String .
	op tracerAux{_}(_,_) : Nat DNKComp VCMap -> String .

  var Cs : RDNKMap . 
  var P Q : DNKComp .
  vars N TR : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : RDNK .
  vars I J D K : Nat .
  var SI : STEPTYPE .

  eq checkClocks{D,SI}(P, VCs, TR) = if hasIncmpVCs(VCs)
                              then CollectTrace(TR) 
                              else rd{D,SI}(P, VCs, TR)
                             fi .

  eq rd{0,SI}(P, VCs, TR) = if hasIncmpVCs(VCs) then CollectTrace(TR) else "" fi .
  eq rd{D,SI}(c(bot, I), VCs, TR) = if hasIncmpVCs(VCs) then CollectTrace(TR) else "" fi .

  eq rd{D,SI}(P o+ Q, VCs, TR) = rd{D,SI}(P, VCs, TR) + rd{D,SI}(Q, VCs, TR) .

  ---- Sending or receiving alone does not count in the trace, which is similar to applying the delta operator.
  ---- The trace also stops here since the expected behavior of a component is to wait when executing a
  ---- communication instruction until it can synchronize with another component.
  eq rd{s(D),SI}(c((X ! N), I) ; P, VCs, TR) = "" .
  eq rd{s(D),SI}(c((X ? N), I) ; P, VCs, TR) = "" .
  eq rd{s(D),SI}(rcfg(X, N, I, J) ; P, VCs, TR) = checkClocks{D,CommStep}(P, transferVC(VCs, I, J), TR + " ; " + compCommToStr(rcfg(X, N, I, J))) .

  eq rd{s(D),ProcStep}(c(N, I) ; P, VCs, TR) = "" . ---- Heuristic 1: Prune the branch if 2 consecutive packet processing transitions happen
  eq rd{s(D),SI}(c(N, I) ; P, VCs, TR) = checkClocks{D,ProcStep}(P, inc(VCs, I), TR + " ; c('" + N + "', " + string(I, 10) + ")") .

  ceq [rec-4] : rd{D,SI}(P, VCs, TR) = rd{D,SI}(unfold(P), VCs, TR) if notUnfolded(P) .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_RDNK, 1 |-> second_RDNK, 2 |-> third_RDNK, etc.
  eq tracer{D}(BSw, Cs) = rd{D,NoStep}(parallelJoin(BSw, Cs, s(mapLength(Cs))), newVCMap(s(mapLength(Cs))), "") .
endfm
