load dnk.maude
load trace_tree.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting RECURSIVE_DNK .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to StrMap) .
  protecting MAP_UTIL {Nat, RDNK} * (sort Map {Nat, RDNK} to RDNKMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : StrMap -> String .
  op network__ : StrMap String -> String [gather (E e)].
  op bigSwitch__ : StrMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : RDNK RDNKMap Nat -> DNKComp .

  var Sws : StrMap .
  var Cs : RDNKMap . 
  vars BSw C : RDNK .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + "(" + L + ")" .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = c(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || c(C, s(I))) .
endfm

fmod TRACER is
  protecting TRACE_TREE .
  protecting COMM_STRING_CONVERSION .
  protecting TRACER_UTIL .

	op rd{_}(_,_) : Nat DNKComp VCMap -> TraceNodes .
	op makeNode{_}(_,_,_) : Nat String DNKComp VCMap -> TraceNodes .

	op tracer{_}(_,_) : Nat RDNK RDNKMap -> TraceNodes .
	op tracerAux{_}(_,_) : Nat DNKComp VCMap -> TraceNodes .

  var Cs : RDNKMap . 
  var P Q : DNKComp .
  var N : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : RDNK .
  vars I J D : Nat .


  eq makeNode{D}(N, P, VCs) = if hasIncmpVCs(VCs)
                              then TAppend(TNode(TDR, N, VCs, TEmpty), TEmpty)
                              else TAppend(TNode(TNORMAL, N, VCs, rd{D}(P, VCs)), TEmpty)
                              ---- else (if rd{D}(P, VCs) =/= TEmpty
                              ----   then TAppend(TNode(TNORMAL, N, VCs, rd{D}(P, VCs)), TEmpty) ---- TODO Re-enable this (impacts performance)
                              ----   else TEmpty
                              ----   fi)
                              fi .

  eq rd{0}(P, VCs) = TEmpty .
  eq rd{D}(c(bot, I), VCs) = TEmpty .

  eq rd{D}(P o+ Q, VCs) = TConcat(rd{D}(P, VCs), rd{D}(Q, VCs)) .
  ---- TODO: Concat only if it doesn't lead to TEmpty
  ---- HORRIFYINGLY SLOW ceq rd{D}(P o+ Q, VCs) = rd{D}(P, VCs) if (rd{D}(P, VCs) =/= TEmpty) .
  ----                   eq rd{D}(P o+ Q, VCs) = rd{D}(Q, VCs) [owise] .

  ---- Sending or receiving alone does not count in the trace, which is similar to applying the delta operator.
  ---- The trace also stops here since the expected behavior of a component is to wait when executing a
  ---- communication instruction until it can synchronize with another component.
  eq rd{s(D)}(c((X ! N), I) ; P, VCs) = TEmpty .
  eq rd{s(D)}(c((X ? N), I) ; P, VCs) = TEmpty .
  eq rd{s(D)}(rcfg(X, N, I, J) ; P, VCs) = makeNode{D}(compCommToStr(rcfg(X, N, I, J)), P, transferVC(VCs, I, J)) .

  eq rd{s(D)}(c(N, I) ; P, VCs) = makeNode{D}(N, P, inc(VCs, I)) .

	eq [rec-4] : rd{D}(P, VCs) = if notUnfolded(P)
                                then rd{D}(unfold(P), VCs)
                                else rd{D}(P, VCs)
                                fi [owise] .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_RDNK, 1 |-> second_RDNK, 2 |-> third_RDNK, etc.
  eq tracer{D}(BSw, Cs) = tracerAux{D}(parallelJoin(BSw, Cs, s(mapLength(Cs))),
                                       newVCMap(s(mapLength(Cs)))) .
  ceq tracerAux{D}(P, VCs) = TAppend(TNode(TSTART, "", VCs, rd{D}(P, VCs)), TEmpty) if rd{D}(P, VCs) =/= TEmpty . ---- Add start node if trace is not empty
  eq tracerAux{D}(P, VCs) = TEmpty [owise] .
endfm
