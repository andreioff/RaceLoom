load sym_dnk.maude

fmod TRACER_UTIL is 
  protecting STRING .
  protecting TRACE_TREE .
	protecting RECURSIVE_SYM_DNA .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to SwMap) .
  protecting MAP_UTIL {Nat, DNA} * (sort Map {Nat, DNA} to DNAMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : SwMap -> String .
  op network__ : SwMap String -> String [gather (E e)].
  op bigSwitch__ : SwMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : DNA DNAMap Nat -> DNA_VC .

  var Sws : SwMap .
  var Cs : DNAMap . 
  vars BSw C : DNA .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + L .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = vc(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || vc(C, s(I))) .
endfm

fmod TRACER is
  protecting TRACER_UTIL .

	op rd{_}(_,_) : Nat DNA_VC VCMap -> TraceNode .
	op procResult{_}(_,_) : Nat SymRuleResults VCMap -> TraceNode .

	op tracer{_}(_,_) : Nat DNA DNAMap -> TraceNode .
	op tracerAux{_}(_,_) : Nat DNA_VC VCMap -> TraceNode .

  var Results : SymRuleResults .
  var Cs : DNAMap . 
  var P : DNA_VC .
  var N : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  vars BSw : DNA .
  vars I D : Nat .
  var commTransRes : CommTransResult .

  eq procResult{0}(Results, VCs) = TLeaf .
  eq procResult{D}(nil, VCs) = TLeaf .

  ceq procResult{D}((rewriteRes(P) Results), VCs) = rd{D}(P, VCs) if (rd{D}(P, VCs) =/= TLeaf) .
  eq procResult{D}((rewriteRes(P) Results), VCs) = procResult{D}(Results, VCs) [owise] .

  eq procResult{s(D)}((transRes(P, (X ! N), NewVCs) nil), VCs) = rd{D}(P, VCs) . ---- Sending or receiving alone does not count in the trace
  eq procResult{s(D)}((transRes(P, (X ? N), NewVCs) nil), VCs) = rd{D}(P, VCs) .
  eq procResult{D}(commTransRes, VCs) = procResult{D}((ToStrTrans(commTransRes) nil), VCs) . --- Any other communication is converted to string

  ceq procResult{s(D)}((transRes(P, N, NewVCs) nil), VCs) = TNode(N, NewVCs, TEmpty) if hasIncmpVCs(NewVCs) .
  ceq procResult{s(D)}((transRes(P, N, NewVCs) nil), VCs) = TNode(N, NewVCs, appendTNode(rd{D}(P, NewVCs), TEmpty)) if (rd{D}(P, NewVCs) =/= TLeaf) .
  eq procResult{s(D)}((transRes(P, N, NewVCs) nil), VCs) = TLeaf [owise] .


  eq rd{0}(P, VCs) = TLeaf .
  eq rd{D}(vc(bot, I), VCs) = TLeaf .
  eq rd{D}(P, VCs) = procResult{D}(applySymRule(P, VCs), VCs) .

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_DNA, 1 |-> second_DNA, 2 |-> third_DNA, etc.
  eq tracer{D}(BSw, Cs) = tracerAux{D}(parallelJoin(BSw, Cs, s(mapLength(Cs))),
                                       newVCMap(s(mapLength(Cs)))) .
  ceq tracerAux{D}(P, VCs) = TNode("", VCs, appendTNode(rd{D}(P, VCs), TEmpty)) if rd{D}(P, VCs) =/= TLeaf . ---- Add start node if trace is not empty
  eq tracerAux{D}(P, VCs) = TLeaf [owise] .
endfm

fmod TESTING is
  protecting TRACER .

  op SDN_ : SwMap -> Recursive .
  ops SW SWP C C0 : -> Recursive .
  op Link : -> String .
	ops Help Up Up0 : -> Channel .

  var Sws : SwMap .
  var I : Nat .

  eq Link = "(p=3).(p<-0) + (p=1).(p<-15)" .

  ---- TODO: INSERT HERE THE CALL TO NetKATToNF to process the big switch notation
  ---- eq getRecPol(SDN Sws) = (bigSwitch Sws "") ; SDN Sws o+
  ----                         (Up0 ? "test0") ; SDN insert(0, "test0", Sws) .
  ---- 
  ---- eq getRecPol(C0) = (Up0 ! "test0") ; C0 .


  eq getRecPol(SW) = "(f = r) . (pt = 1) . (pt <- 2)" ; SW o+
                      "(f = b) . (pt = 1)" ; ( (Help ! "one") ; SW ) o+
                      (Up ? "one") ; SWP .
  eq getRecPol(SWP) = "zero" ; SWP .
  eq getRecPol(C) = (Help ? "one") ; ( (Up ! "one") ; C ) .
endfm
