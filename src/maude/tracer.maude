load dnk.maude
load vector_clock.maude

fmod TRACER_UTIL is 
  protecting STRING .
	protecting RECURSIVE_DNK .
	protecting MAP_UTIL {Nat, String} * (sort Map {Nat, String} to StrMap) .
  protecting MAP_UTIL {Nat, RDNK} * (sort Map {Nat, RDNK} to RDNKMap) .


  --- Operator with special hook. Works only with the Python package Maude.
  --- More details here: https://github.com/fadoss/maude-bindings
  op NetKATToNF : String -> String [special (
      id-hook SpecialHubSymbol
  )] .
  op CollectTrace : String -> String [special (
      id-hook SpecialHubSymbol
  )] .

  op concatSws_ : StrMap -> String .
  op network__ : StrMap String -> String [gather (E e)].
  op bigSwitch__ : StrMap String -> String [gather (E e)].
  op parallelJoin(_,_,_) : RDNK RDNKMap Nat -> DNKComp .

  var Sws : StrMap .
  var Cs : RDNKMap . 
  vars BSw C : RDNK .
  vars I VCSize : Nat .
  vars L X : String .

  eq concatSws empty = "" .
  eq concatSws (I |-> X , empty) = X .
  eq concatSws (I |-> X , Sws) = X + "+" + concatSws Sws .

  eq network Sws L = "(" + (concatSws Sws) + ") . " + "(" + L + ")" .
  eq bigSwitch Sws L = (network Sws L) + " . (" + (network Sws L) + ")*" .

  eq parallelJoin(BSw, empty, VCSize) = c(BSw, 0) .
  eq parallelJoin(BSw, (I |-> C , Cs), VCSize) = (parallelJoin(BSw, Cs, VCSize) || c(C, s(I))) .
endfm


fmod TRACE_STATE is
  protecting STRING .
  protecting VECTOR_CLOCK_MAP .
	protecting RECURSIVE_DNK .

  sort Node .

  ---- args: id, starting DNK expression, starting vector clocks
  op snode(_,_,_) : Nat DNKComp VCMap -> Node .
  ---- args: id, parent id, remaining DNK expression, transition label, updated vector clocks
  op node(_,_,_,_,_) : Nat Nat DNKComp String VCMap -> Node .
endfm

view Node from TRIV to TRACE_STATE is
  sort Elt to Node .
endv

fmod HEAD_NORMAL_FORM is
  protecting COMM_STRING_CONVERSION .
  protecting TRACER_UTIL .
  protecting CONVERSION .
  protecting TRACE_STATE .
	protecting LIST {Node} * (sort List {Node} to NodeList) .

  ---- args: DNK exprs to reduce, vector clocks, parent node id
  op hnf(_,_,_) : DNKComp VCMap Nat -> NodeList .

  var P Q : DNKComp .
  var N : String .
  var X : Channel .
  var VCs : VCMap .
  vars I J PID : Nat .

  eq hnf(c(bot, I), VCs, PID) = nil .

  eq hnf(P o+ Q, VCs, PID) = append(hnf(P, VCs, PID), hnf(Q, VCs, PID)) .

  ---- Sending or receiving alone does not count in the trace, which is similar to applying the delta operator.
  ---- The trace also stops here since the expected behavior of a component is to wait when executing a
  ---- communication instruction until it can synchronize with another component.
  eq hnf(c((X ! N), I) ; P, VCs, PID) = nil .
  eq hnf(c((X ? N), I) ; P, VCs, PID) = nil .
  eq hnf(rcfg(X, N, I, J) ; P, VCs, PID) = (node(0, PID, P, compCommToStr(rcfg(X, N, I, J)), transferVC(VCs, I, J)) nil) .

  eq hnf(c(N, I) ; P, VCs, PID) = (node(0, PID, P, "proc(\"" + N + "\"," + string(I, 10) + ")", inc(VCs, I)) nil) .

  ceq [rec-4] : hnf(P, VCs, PID) = hnf(unfold(P), VCs, PID) if notUnfolded(P) [owise] .
endfm

view NodeList from TRIV to HEAD_NORMAL_FORM is
  sort Elt to NodeList .
endv

fmod TRACES_COLLECTOR is
  protecting STRING .
  protecting HEAD_NORMAL_FORM .
	protecting MAP_UTIL {Nat, NodeList} * (sort Map {Nat, NodeList} to NodeListMap) .

  op startTrace(_) : VCMap -> String .
  op traceAppend(_,_,_) : String String VCMap -> String .
  op collectTraces{_}(_) : Nat NodeListMap -> String .
  op $collectTraces{_}(_,_,_) : Nat NodeListMap Nat String -> String .

  vars N TR : String .
  var VCs : VCMap .
  var P : DNKComp .
  vars D ID PID PID2 : Nat .
  var RemMap : NodeListMap .
  vars Nodes RemNodes : NodeList .

  eq collectTraces{0}(RemMap) = "" .
  eq collectTraces{s(D)}((s(D) |-> (snode(ID, P, VCs) RemNodes), RemMap)) = $collectTraces{D}(RemMap, ID, startTrace(VCs)) .
  eq collectTraces{D}((D |-> (node(ID, PID, P, N, VCs) RemNodes), RemMap)) =
    collectTraces{D}((D |-> RemNodes, RemMap)) . ---- only start nodes should exist in the first pair of the map
  eq collectTraces{D}(RemMap) = "" [owise] .


  eq $collectTraces{0}(RemMap, PID, TR) = "" .
  eq $collectTraces{D}(empty, PID, TR) = "" .
  eq $collectTraces{D}((D |-> nil, RemMap), PID, TR) = "" .
  eq $collectTraces{D}((D |-> (snode(ID, P, VCs) RemNodes), RemMap), PID, TR) = 
    $collectTraces{D}((D |-> RemNodes, RemMap), PID, TR) . ---- start nodes are allowed only in the first pair of the map

  eq $collectTraces{s(D)}((s(D) |-> (node(ID, PID2, P, N, VCs) RemNodes), RemMap), PID, TR) = 
    if PID2 == PID and hasIncmpVCs(VCs) then
      CollectTrace("[" + traceAppend(TR, N, VCs) + "]")
    else (if PID2 == PID then
      $collectTraces{D}(RemMap, ID, traceAppend(TR, N, VCs))
    else
      ""
    fi) fi + $collectTraces{s(D)}((s(D) |-> RemNodes, RemMap), PID, TR) .
  eq $collectTraces{D}(RemMap, PID, TR) = "" [owise] .

  eq startTrace(VCs) = "(\"\",[" + VCMapToString(VCs) + "])" .
  ---- the shape of the appended terms should match Python objects of type Tuple[str, List[List[int]]]
  eq traceAppend(TR, N, VCs) = TR + ",(\"" + N + "\",[" + VCMapToString(VCs) + "])" .
endfm

view NodeListMap from TRIV to TRACES_COLLECTOR is
  sort Elt to NodeListMap .
endv


fmod TRACER is
  protecting TRACE_STATE .
  protecting TRACES_COLLECTOR .
  protecting HEAD_NORMAL_FORM .
  protecting COMM_STRING_CONVERSION .
  protecting TRACER_UTIL .
  protecting STRING .
  protecting CONVERSION .

  sort AssignIdsResult .

  op getNext(_) : NodeList -> NodeList .
  op filter(_) : NodeList -> NodeList .

  op assignIds(_,_) : NodeList Nat -> AssignIdsResult .
  op $assignIds(_,_,_) : NodeList NodeList Nat -> AssignIdsResult .
  op assignIdsResult(_,_) : NodeList Nat -> AssignIdsResult .

	op rd{_}(_,_) : Nat NodeList Nat -> NodeListMap .
	op $rd{_}(_) : Nat AssignIdsResult -> NodeListMap .

	op tracer{_}(_,_) : Nat RDNK RDNKMap -> String .

  var Cs : RDNKMap . 
  var P Q : DNKComp .
  vars N TR : String .
  var X : Channel .
  vars NewVCs VCs : VCMap .
  var BSw : RDNK .
  vars I J D K ID PID NID : Nat .
  vars Nodes RemNodes : NodeList .

  eq getNext(nil) = nil .
  eq getNext(snode(ID, P, VCs) RemNodes) = (hnf(P, VCs, ID) getNext(RemNodes)) .
  eq getNext(node(ID, PID, P, N, VCs) RemNodes) = (hnf(P, VCs, ID) getNext(RemNodes)) .

  eq rd{0}(Nodes, NID) = (0 |-> Nodes, empty) .
  eq rd{D}(nil, NID) = empty .
  eq rd{s(D)}(Nodes, NID) = insert(s(D), Nodes, $rd{D}(assignIds(getNext(filter(Nodes)), NID))) .
  eq $rd{D}(assignIdsResult(Nodes, NID)) = rd{D}(Nodes, NID) .

  eq assignIds(Nodes, NID) = $assignIds(Nodes, nil, NID) .
  eq $assignIds(nil, Nodes, NID) = assignIdsResult(Nodes, NID) .
  eq $assignIds((snode(ID, P, VCs) RemNodes), Nodes, NID) = $assignIds(RemNodes, append(snode(NID, P, VCs), Nodes), s(NID)) .
  eq $assignIds((node(ID, PID, P, N, VCs) RemNodes), Nodes, NID) = $assignIds(RemNodes, append(node(NID, PID, P, N, VCs), Nodes), s(NID)) .

  eq filter(nil) = nil .
  eq filter((node(ID, PID, P, N, VCs) RemNodes)) = if hasIncmpVCs(VCs) then filter(RemNodes) else (node(ID, PID, P, N, VCs) filter(RemNodes)) fi .
  eq filter((snode(ID, P, VCs) RemNodes)) = if hasIncmpVCs(VCs) then filter(RemNodes) else (snode(ID, P, VCs) filter(RemNodes)) fi .
  ---- TODO Add heuristic

  --- Assumes that the Cs map mimics an array, i.e. its keys start from 0 and increase by 1 with every position.
  --- E.g. 0 |-> first_RDNK, 1 |-> second_RDNK, 2 |-> third_RDNK, etc.
  eq tracer{0}(BSw, Cs) = "" .
  eq tracer{D}(BSw, Cs) = collectTraces{D}(
      rd{D}(
        snode(0, parallelJoin(BSw, Cs, s(mapLength(Cs))), newVCMap(s(mapLength(Cs)))),
        1
      )
  ) .
endfm
