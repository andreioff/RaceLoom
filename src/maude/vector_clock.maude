load map_util.maude

fmod VECTOR_CLOCK is 
  protecting CONVERSION .
  protecting TRUTH-VALUE .
	protecting MAP {Nat, Nat} * (sort Map {Nat, Nat} to VClock) .
  
  op newVC(_) : Nat -> VClock .
  op inc(_,_) : VClock Nat -> VClock .
  op maxVC(_,_) : VClock VClock -> VClock .
  op areIncmp(_,_) : VClock VClock -> Bool .
  op smallerEq(_,_) : VClock VClock -> Bool .
  op VCToString(_) : VClock -> String .

  vars VC1 VC2 : VClock .
  vars N I J X : Nat .
  var B : Bool .

  eq newVC(0) = empty .
  eq newVC(s(N)) = insert(N, 0, newVC(N)) .

  ceq inc(VC1, I) = insert(I, s(VC1[I]), VC1) if not VC1[I] == undefined .

  
  ---- Returns a new vector clock with the maximum values of all COMMON entries of the two given vector clocks
  ---- Example: maxVC((0 |-> 1, 1 |-> 3, 2 |-> 4),
  ----                (0 |-> 2, 2 |-> 2, 4 |-> 5)) reduces to (0 |-> 2, 2 |-> 4)
  eq maxVC(empty, VC2) = empty .
  eq maxVC(VC1, empty) = empty .
  ceq maxVC((I |-> X, VC1), VC2) = insert(I, max(X, VC2[I]), maxVC(VC1, VC2)) if VC2[I] =/= undefined .
  eq maxVC((I |-> X, VC1), VC2) = maxVC(VC1, VC2) [owise] .

  eq areIncmp(empty, VC2) = false .
  eq areIncmp(VC1, empty) = false .
  ceq areIncmp((I |-> X, VC1), VC2)
     = if X < VC2[I] 
       then (not smallerEq(VC1, VC2))
       else (not smallerEq(VC2, VC1))
       fi if (VC2[I] =/= undefined) /\ (VC2[I] =/= X) .
  eq areIncmp((I |-> X, VC1), VC2) = areIncmp(VC1, VC2) [owise] .

  --- comparison is done only on the common elements
  eq smallerEq(empty, VC2) = true .
  eq smallerEq(VC1, empty) = true .
  ceq smallerEq((I |-> X, VC1), VC2) = false if VC2[I] =/= undefined /\ X > VC2[I] .
  eq smallerEq((I |-> X, VC1), VC2) = smallerEq(VC1, VC2) [owise] .

  eq VCToString(empty) = "" .
  eq VCToString(I |-> X, empty) = string(X, 10) + "" .
  eq VCToString(I |-> X, VC1) = string(X, 10) + ", " + VCToString(VC1) .
endfm

view VCLOCK from TRIV to VECTOR_CLOCK is
  sort Elt to VClock .
endv

fmod VECTOR_CLOCK_MAP is
  protecting VECTOR_CLOCK .
  protecting MAP_UTIL {Nat, VCLOCK} * (sort Map {Nat, VCLOCK} to VCMap) .

  --- Assumes the position corresponds to the correct vector clock of a component in the map, but also to the same component in the vector clock itself
  op inc(_,_) : VCMap Nat -> VCMap .
  --- Applies the transfer rule between 2 vector clocks: vc1 becomes vc1[i]++ and vc2 becomes max(vc1[i]++, vc2)[j]++ 
  op transferVC(_,_,_) : VCMap Nat Nat -> VCMap .
  op newVCMap(_) : Nat -> VCMap .
  op newVCMapAux(_,_) : Nat Nat -> VCMap .
  op hasIncmpVCs(_) : VCMap -> Bool .
  op hasIncmpVCsAux(_,_) : VClock VCMap -> Bool .
  op VCMapToString(_) : VCMap -> String .

  var VCs : VCMap .
  var VC1 VC2 : VClock .
  vars I J VCSize : Nat .

  ceq inc(VCs, I) = insert(I, inc(VCs[I], I), VCs) if VCs[I] =/= undefined .

  ceq transferVC(VCs, I, J) = insert(J, inc(maxVC(inc(VCs[I], I), VCs[J]), J), inc(VCs, I)) if (VCs[I] =/= undefined) /\ (VCs[J] =/= undefined) .

  --- creates a map containing the same amount of vector clocks as a vector clock size (equivalent to the nr of components)
  eq newVCMap(VCSize) = newVCMapAux(VCSize, VCSize) .
  eq newVCMapAux(0, VCSize) = empty .
  eq newVCMapAux(s(I), VCSize) = insert(I, newVC(VCSize), newVCMapAux(I, VCSize)) .

  eq hasIncmpVCs(empty) = false .
  ceq hasIncmpVCs(I |-> VC1, VCs) = true if hasIncmpVCsAux(VC1, VCs) .
  eq hasIncmpVCs(I |-> VC1, VCs) = hasIncmpVCs(VCs) [owise] . 

  eq hasIncmpVCsAux(VC1, empty) = false .
  ceq hasIncmpVCsAux(VC1, (I |-> VC2, VCs)) = true if areIncmp(VC1, VC2) .
  eq hasIncmpVCsAux(VC1, (I |-> VC2, VCs)) = hasIncmpVCsAux(VC1, VCs) [owise] .

  eq VCMapToString(empty) = "" .
  eq VCMapToString(I |-> VC1, empty) = "<" + VCToString(VC1) + ">" .
  eq VCMapToString(I |-> VC1, VCs) = "<" + VCToString(VC1) + "> || " + VCMapToString(VCs) .
endfm
